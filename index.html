<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>De/Centralise</title>
    <script type="text/javascript" src="d3/d3.js"></script>
</head>

<body>
    <div id="simulation"></div>
    <div>
        <button onClick="centralise();">Centralise</button>
    </div>
    <div>
        <button onClick="decentralise();">Decentralise</button>
    </div>

    <!-- JAVASCRIPT FILE -->
    <script type="text/javascript">

        var w = window.innerWidth,
            h = window.innerHeight;

        var svg = d3.select("#simulation").append("svg:svg")
            .attr("width", w)
            .attr("height", h);

        var nodes = d3.range(100).map(d => {
            return {
                power: Math.floor(Math.random() * 100),
                x: Math.random() * w,
                y: Math.random() * h,
                linkedNum: 0
            }
        })

        // nodes = [{}{}{}...]
        function createNodes() {
            //CREATE NODES
            var nodeSelection = d3.select('#simulation')
                .select('div')
                .selectAll('node')
                .data(nodes, function (d) { return d; })                 // data key join because we're using transition

            nodeSelection.enter()
                .append('node')
                .merge(nodeSelection)
                .transition()
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr("r", function (d) { return d.r; });
        }

        function updateNodes() {
            nodes.map(d => {
                return {
                    power: d.power,
                    x: d.x,
                    y: d.y,
                    r: d.power / 3,
                    linkLength: d.power / 10,
                    linkNum: d.power * 10,
                    linkedNum: 0
                }
            })
        }

        // links = [{source: node1, target: node2}{source: node1, target: node3}{}...]
        var links = []

        function updateLinks() {
            for each node,
                while linkedNum = linkNum, 
                    do nothing

                    while linkedNum > LinkNum,
                        pick one of its targets, if linkedNum of target > linkNum, if power of target <= power of self
            delete link between them from links array
            decrease linkedNum of source and target

            while linkedNum < linkNum,
                pick a random target, if linkedNum of target < linkNum, and distance to target <= linkLength source or target
            create link between source and target in links array
            increase linkedNum of source and target
        }

        var simulate = d3.forceSimulation()
            .force('charge', d3.forceManyBody().strength(10))
            .force('gravity', d3.forceCenter(w / 2, h / 2))
            .force('collision', d3.forceCollide(20).strength(.3))
            .force('link', d3.forceLink().links(links))

        function visualise() {
            //REMOVE AND ADD LINKS
            var linkSelection = d3.select('#simulation')
                .select('div')
                .selectAll('link')                                      // select simulation-div-allLink elements
                .data(links, function (d) { return d; })                  // data key join because we're using transition

            linkSelection.transition()
                .exit()
                .remove()

            linkSelection.enter()                                       // if length.join > corresponding DOM elements
                .append('link')                                         // create new corresponding DOM elements
                .merge(linkSelection)                                   // merge the newly created elements with earlier selection
                .transition()
                    .attr("x1", function (d) { return d.source.x; })     // create svg on the DOM element selection
                    .attr("y1", function (d) { return d.source.y; })
                    .attr("x2", function (d) { return d.target.x; })
                    .attr("y2", function (d) { return d.target.y; })

            //UPDATE NODES
            d3.select('#simulation')
                .select('div')
                .selectAll('node')
                .data(nodes, function (d) { return d; })                 // data key join because we're using transition
                .transition()
                .attr("r", function (d) { return d.r; });
        }

        function initiate() {
            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);                             // when this runs, the nodes array is updated again
        }

        function centralise() {

            links.forEach(function (link) {

                var sourceNode = nodes[link.source];
                var targetNode = nodes[link.target];

                if(sourceNode.power >= targetNode.power && targetNode.power > 10) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power;
                } else if(sourdeNode.power < targetNode.power && sourceNode.power > 10) {
                    sourceNode.power = sourceNode.power - 10 % targetNode.power;
                    targetNode.power = targetNode.power + 10 % targetNode.power
                }

            });

            // for each link, 
            //     if source.power >= target.power, and target.power > 10
            // set source.power = source.power + 10 % target.power and set target.power = target.power - 10 % target.power
            // if source.power <= target.power, and source.power > 10
            // set source.power = source.power - 10 % target.power and set target.power = target.power + 10 % target.power

            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);                             // when this runs, the nodes array is updated again
        }

        function decentralise() {
            for each link, 
                if source.power > target.power, and target.power > 10
            set source.power = source.power - 10 % target.power and set target.power = target.power + 10 % target.power
            if source.power < target.power, and source.power > 10
            set source.power = source.power + 10 % target.power and set target.power = target.power - 10 % target.power

            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);                             // when this runs, the nodes array is updated again
        }
    </script>
</body>

</html>