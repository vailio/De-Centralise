<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
   
    <title>De/Centralise</title>
    <h1>hello</h1>
</head>
<style>
    /* rect {
        fill: none;
        pointer-events: all;
    } */

    /* .circle {
        fill: #222;
    }

    .line {
        stroke: #333;
    } */
</style>
<body>
    <!-- <div id="simulation"></div> -->
    <div>
        <button onclick="centralise();">Centralise</button>
    </div>
    <div>
        <button onclick="decentralise();">Decentralise</button>
    </div>
    <script src="d3.js"></script>
    <script src="lodash.js"></script>
    <script type="text/javascript">

        var w = window.innerWidth - 40,
            h = window.innerHeight - 40;

        var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h);

        d3.select('body').select('svg')
            .append("rect")
            .attr("width", w)
            .attr("height", h)
            .style('fill', "#000000")

        var nodes = d3.range(100).map(d => {
            var p = Math.floor((Math.random() * 100) + 1)
            return {
                power: p,
                x: (Math.random() * w) - p/5,
                y: (Math.random() * h) - p/5,
                linkedNum: 0,
                r: p/5,
                linkLength: p * 4, //* (Math.sqrt(w * w + h * h )) / 100,
                linkNum: p/10,
            }
        })

        function createNodes() {                                
            //CREATE NODES
            d3.select('svg')
                .selectAll('circle')
                .data(nodes)             
                .enter()
                .append('circle')
                .transition()
                    .attr('cx', function (d) { return d.x; })
                    .attr('cy', function (d) { return d.y; })
                    .attr('r', function (d) { return d.r; })
                    .style("fill",  "#ff0000");
                // .attr('fill', 000000)
        }

        function createLinks() {
             d3.select('svg')
                .selectAll('line')                                      
                .data(links, function(d) {return d})
                .enter()                                       
                .append('line') 
                // .merge(v)                                        
                .transition()
                    .attr("x1", function (d) {return d.source.x;})     
                    .attr("y1", function (d) {return d.source.y;})
                    .attr("x2", function (d) {return d.target.x;})
                    .attr("y2", function (d) {return d.target.y;})
                    .style("stroke",  "#444444");
        }

        var links = []

        function updateLinks() {

            nodes.forEach(function (node, index) {

                if (node.linkedNum > node.linkNum) {

                    var linksWhereNodeIsSourceOrTarget = _.filter(links, function (link) {                          //filter all links for links of this node in new array
                        return link.source == node.index || link.target == node.index;
                    });

                    linksWhereNodeIsSourceOrTarget.forEach(function (link) {

                        var otherNode = link.source != node.index ? nodes[link.source] : nodes[link.target];        // for each link, get the other node

                        if (otherNode.linkedNum > otherNode.linkNum && otherNode.power <= node.power) {             // if the other node also has to delete links
                            links.splice(link.index, 1);
                            linksWhereNodeIsSourceOrTarget.splice(link.index, 1);
                            node.linkedNum = node.linkedNum - 1;
                            otherNode.linkedNum = otherNode.linkedNum - 1;
                        }

                    });

                } else if (node.linkedNum < node.linkNum) {

                    var linksWhereNodeIsSourceOrTarget = _.filter(links, function (link) {                          //filter all links for links of this node in new array
                        return link.source == node.index || link.target == node.index;
                    });

                    var unavailableTargets = [];

                    unavailableTargets.push(node)

                    linksWhereNodeIsSourceOrTarget.forEach(function (link) {                                        //List nodes with which links exist
                        if (link.source == node.index) { unavailableTargets.push(link.target) }
                        else if (link.target == node.index) { unavailableTargets.push(link.source) }

                    });

                    availableTargets = nodes.filter(function (node) {                                               //List Targets available for new links
                        return !unavailableTargets.includes(node);
                    })

                    availableTargets.forEach(function (target) {
                        var x = target.x - node.x
                        var y = target.y - node.y
                        var distanceToTarget = Math.sqrt(x * x + y * y)

                        if (node.linkedNum < node.linkNum 
                            && target.linkedNum < target.linkNum 
                            && distanceToTarget <= target.linkLength ) {     // if the other node also wants links
                                newLink = { source: node, target: target }
                                links.push(newLink);
                                linksWhereNodeIsSourceOrTarget.push(newLink);
                                node.linkedNum = node.linkedNum + 1;
                                target.linkedNum = target.linkedNum + 1;
                        }
                    })
                }
            });
        }

        var simulate = d3.forceSimulation(nodes)
            .force('charge', d3.forceManyBody().strength(10))
            .force('gravity', d3.forceCenter(w / 2, h / 2))
            .force('collision', d3.forceCollide(20).strength(.3))
            // .force('link', d3.forceLink().links(links))

        function visualise() {
            //REMOVE AND ADD LINKS
                // var v = d3.select('svg')
                //     .selectAll('link')                                      
                //     .data(links, function(d) {return d});
                // v.enter()                                       
                //     .append('line') 
                //     .merge(v)                                        
                //     .transition()
                //     .attr("x1", function (d) {return d.source.x;})     
                //     .attr("y1", function (d) {return d.source.y;})
                //     .attr("x2", function (d) {return d.target.x;})
                //     .attr("y2", function (d) {return d.target.y;})

            var w = d3.select('svg')
                .selectAll('node')
                .data(nodes)             
                
            w.enter()
                .append('circle')
                .transition()
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr('r', function (d) { return d.r; });

            // //UPDATE NODES
            d3.select('svg')
                .selectAll('circle')                                      
                .data(nodes, function (d) {return d;})
                .transition()
                    .attr("cx", function (d) {return d.x;})
                    .attr("cy", function (d) {return d.y;})
                    .attr("r", function (d) {return d.r;})
        }

        function initiate() {
            createNodes()
            updateLinks()
            createLinks()
            // simulate.on("tick", visualise);                             
        }

        initiate()

        function centralise() {

            links.forEach(function (link) {

                var sourceNode = nodes[link.source];
                var targetNode = nodes[link.target];

                if (sourceNode.power >= targetNode.power && targetNode.power > 10) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power;
                } else if (sourdeNode.power < targetNode.power && sourceNode.power > 10) {
                    sourceNode.power = sourceNode.power - 10 % targetNode.power;
                    targetNode.power = targetNode.power + 10 % targetNode.power
                }
            });

            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);                             
        }

        function decentralise() {

            links.forEach(function (link) {

                var sourceNode = nodes[link.source];
                var targetNode = nodes[link.target];

                if (sourceNode.power >= targetNode.power && targetNode.power > 10) {
                    sourceNode.power = sourceNode.power - 10 % targetNode.power;
                    targetNode.power = targetNode.power + 10 % targetNode.power;
                } else if (sourdeNode.power < targetNode.power && sourceNode.power > 10) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power
                }
            });

            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);
        }
    </script>
</body>

</html>