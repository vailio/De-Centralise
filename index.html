<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <style>
        rect {
            fill: none;
            pointer-events: all;
        }

        .node {
            fill: #000;
        }

        /* .cursor {
          fill: none;
          stroke: brown;
          pointer-events: none;
        } */

        .link {
            stroke: #999;
        }
    </style>
    <title>De/Centralise</title>
</head>

<body>
    <!-- <div id="simulation"></div> -->
    <div>
        <button onclick="centralise();">Centralise</button>
    </div>
    <div>
        <button onclick="decentralise();">Decentralise</button>
    </div>
    <script src="d3.js"></script>
    <script src="lodash.js"></script>
    <script type="text/javascript">

        var w = window.innerWidth,
            h = window.innerHeight;

        var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h);

        d3.select('body').select('svg')
            .append("rect")
            .attr("width", w)
            .attr("height", h);

        var nodes = d3.range(10).map(d => {
            return {
                power: Math.floor((Math.random() * 100) + 1),
                x: Math.random() * w,
                y: Math.random() * h,
                linkedNum: 0,
                r: 3,
                linkLength: 200,
                linkNum: 4,
            }
        })

        function createNodes() {                                        // create node elements in the svg
            //CREATE NODES
            d3.select('svg')
                .selectAll('node')
                .data(nodes)                 // data key join because we're using transition
                .enter()
                .append('circle')
                // .merge(nodeSelection)
                .transition()
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr("r", function (d) { return d.r; });
        }

        // createNodes()

        // function updateNodes() {
        //     nodes = nodes.map(d => {
        //         return {
        //             power: d.power,
        //             x: d.x,
        //             y: d.y,
        //             r: d.power / 3,
        //             linkLength: d.power / 10,
        //             linkNum: d.power / 10,
        //             linkedNum: d.linkedNum,
        //             vx: d.vx,
        //             vy: d.vy,
        //         }
        //     })
        // }

        // function updateNodes() {
        //     nodes.forEach(function (d) {
        //         d.r = d.power / 3;
        //         d.linkLength = d.power / 10;
        //         d.linkNum = Math.floor(d.power / 10);
        //     }
        //     )
        // }

        var links = []

        function updateLinks() {

            nodes.forEach(function (node) {

                //while?
                if (node.linkedNum > node.linkNum) {

                    //why not use the links array directly?
                    // var temporaryLinkAarray = links.map(function (link, index) {                        
                    //     return {
                    //         index: index,
                    //         source: link.source,
                    //         target: link.target,
                    //     };
                    // });

                    var linksWhereNodeIsSourceOrTarget = _.filter(links, function (link) { //filter all links for links of this node in new array
                        return link.source == node.index || link.target == node.index;
                    });

                    linksWhereNodeIsSourceOrTarget.forEach(function (link) {

                        var otherNode = link.source != node.index ? nodes[link.source] : nodes[link.target];   // for each link, get the other node

                        if (otherNode.linkedNum > otherNode.linkNum && otherNode.power <= node.power) {   // if the other node also has to delete links
                            links.splice(link.index, 1);
                            linksWhereNodeIsSourceOrTarget.splice(link.index, 1);
                            node.linkedNum = node.linkedNum - 1;
                            otherNode.linkedNum = otherNode.linkedNum - 1;
                            //stop if node.linkedNum !> node.linkNum
                        }

                    });

                    // links = temporaryLinkArray.map(function (link) {
                    //     return {
                    //         source: link.source,
                    //         target: link.target,
                    //     }
                    // })

                } else if (node.linkedNum < node.linkNum) {

                    var linksWhereNodeIsSourceOrTarget = _.filter(links, function (link) {                   //filter all links for links of this node in new array
                        return link.source == node.index || link.target == node.index;
                    });

                    var unavailableTargets = [];

                    unavailableTargets.push(node)

                    linksWhereNodeIsSourceOrTarget.forEach(function (link) {                                 //List nodes with which links exist
                        if (link.source == node.index) { unavailableTargets.push(link.target) }
                        else if (link.target == node.index) { unavailableTargets.push(link.source) }

                    });

                    availableTargets = nodes.filter(function (node) {                                         //List Targets available for new links
                        return !unavailableTargets.includes(node);
                    })

                    availableTargets.forEach(function (target) {
                        var x = target.x - node.x
                        var y = target.y - node.y
                        var distanceToTarget = Math.sqrt(x * x + y * y)

                        if (node.linkedNum < node.linkNum && target.linkedNum < target.linkNum && distanceToTarget <= target.linkLength) {     // if the other node also wants links
                            newLink = { source: node, target: target }
                            links.push(newLink);
                            linksWhereNodeIsSourceOrTarget.push(newLink);
                            node.linkedNum = node.linkedNum + 1;
                            target.linkedNum = target.linkedNum + 1;
                        }
                    })
                }
            });

            // for each node,
            // while linkedNum = linkNum, 
            // do nothing

            // while linkedNum > LinkNum,
            // pick one of its targets, if linkedNum of target > linkNum, if power of target <= power of self
            // delete link between them from links array
            // decrease linkedNum of source and target

            // while linkedNum < linkNum,
            // pick a random target, if linkedNum of target < linkNum, and distance to target <= linkLength source or target
            // create link between source and target in links array
            // increase linkedNum of source and target
        }

        var simulate = d3.forceSimulation(nodes)
            .force('charge', d3.forceManyBody().strength(10))
            .force('gravity', d3.forceCenter(w / 2, h / 2))
            .force('collision', d3.forceCollide(20).strength(.3))
            .force('link', d3.forceLink().links(links))

        function visualise() {
            //REMOVE AND ADD LINKS
            //     var v = d3.select('svg')
            //         .selectAll('link')                                      // select simulation-div-allLink elements
            //         .data(links, function(d) {
            // 	return d;
            // });
            //                           // data key join because we're using transition
            //     v.enter()                                       // if length.join > corresponding DOM elements
            //         .append('line') 
            //         .merge(v)                                        // create new corresponding DOM elements
            //         .transition()
            //         .attr("x1", function (d) { return d.source.x; })     // create svg on the DOM element selection
            //         .attr("y1", function (d) { return d.source.y; })
            //         .attr("x2", function (d) { return d.target.x; })
            //         .attr("y2", function (d) { return d.target.y; })

            // //UPDATE NODES
            var w = d3.select('svg')
                .selectAll('link')                                      // select simulation-div-allLink elements
                .data(nodes, function (d) {return d;})
                .transition()
                    .attr('cx', function (d) {return d.x;})
                    .attr('cy', function (d) {return d.y;})
                    .attr("r", function (d) {return d.r;});
        }

        function initiate() {
            // updateNodes()
            createNodes()
            updateLinks()
            simulate.on("tick", visualise);                             // when this runs, the nodes array is updated again
        }

        initiate()

        function centralise() {

            links.forEach(function (link) {

                var sourceNode = nodes[link.source];
                var targetNode = nodes[link.target];

                if (sourceNode.power >= targetNode.power && targetNode.power > 10) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power;
                } else if (sourdeNode.power < targetNode.power && sourceNode.power > 10) {
                    sourceNode.power = sourceNode.power - 10 % targetNode.power;
                    targetNode.power = targetNode.power + 10 % targetNode.power
                }
            });

            // for each link, 
            //     if source.power >= target.power, and target.power > 10
            // set source.power = source.power + 10 % target.power and set target.power = target.power - 10 % target.power
            // if source.power <= target.power, and source.power > 10
            // set source.power = source.power - 10 % target.power and set target.power = target.power + 10 % target.power

            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);                             // when this runs, the nodes array is updated again
        }

        function decentralise() {

            links.forEach(function (link) {

                var sourceNode = nodes[link.source];
                var targetNode = nodes[link.target];

                if (sourceNode.power >= targetNode.power && targetNode.power > 10) {
                    sourceNode.power = sourceNode.power - 10 % targetNode.power;
                    targetNode.power = targetNode.power + 10 % targetNode.power;
                } else if (sourdeNode.power < targetNode.power && sourceNode.power > 10) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power
                }
            });

            // for each link, 
            //     if source.power > target.power, and target.power > 10
            // set source.power = source.power - 10 % target.power and set target.power = target.power + 10 % target.power
            // if source.power < target.power, and source.power > 10
            // set source.power = source.power + 10 % target.power and set target.power = target.power - 10 % target.power

            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);                             // when this runs, the nodes array is updated again
        }
    </script>
</body>

</html>