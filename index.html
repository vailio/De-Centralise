<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>De/Centralise</title>
</head>

<body>
    <div>
        <button onclick="centralise();">Centralise</button>
    </div>
    <div>
        <button onclick="decentralise();">Decentralise</button>
    </div>
    <script src="d3.js"></script>
    <script src="lodash.js"></script>
    <script type="text/javascript">

        var simulation = null;

        var w = window.innerWidth - 40,
            h = window.innerHeight - 40;

        var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h);

        d3.select('body').select('svg')
            .append("rect")
            .attr("width", w)
            .attr("height", h)
            .style('fill', "#FFFFFF")

        var nodes = d3.range(40).map(d => {
            var p = Math.floor((Math.random() * 100) + 10)
            return {
                power: p,
                x: (Math.random() * w) - p / 5,
                y: (Math.random() * h) - p / 5,
                linkedNum: 0,
                r: p / 10,
                linkLength: p * 4,
                linkNum: p / 10,
            }
        })

        function createNodes() {
            d3.select('svg')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .transition()
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr('r', function (d) { return d.r; })
                .style("fill", "#ff0000");
        }

        function createLinks() {
            d3.select('svg')
                .selectAll('line')
                .data(links, function (d) { return d })
                .enter()
                .append('line')
                .transition()
                .attr("x1", function (d) { return d.source.x; })
                .attr("y1", function (d) { return d.source.y; })
                .attr("x2", function (d) { return d.target.x; })
                .attr("y2", function (d) { return d.target.y; })
                .style("stroke", "#444444");
        }

        var links = []

        function updateLinks() {

            nodes.forEach(function (node, index) {

                var temporaryLinkAarray = links.map(function (link) {
                        return {
                            index: link.index,
                            source: link.source,
                            target: link.target,
                        };
                    });

                if (node.linkedNum > node.linkNum) {

                    var linksOfNode = _.filter(temporaryLinkAarray, function (link) {
                        return link.source.index == node.index || link.target.index == node.index;
                    });

                    console.log(node)
                    console.log(temporaryLinkAarray)
                    console.log(linksOfNode)

                    linksOfNode.forEach(function (link) {

                        // var otherNode = link.source != index ? nodes[link.source] : nodes[link.target];

                        var otherNode = link.source.index != node.index ? link.source : link.target;

                        if (node.linkedNum > node.linkNum && otherNode.linkedNum > otherNode.linkNum) {
                            links.splice(link.index, 1);
                            node.linkedNum = node.linkedNum - 1;
                            otherNode.linkedNum = otherNode.linkedNum - 1;
                        }

                    });

                }
                // if (node.linkedNum > node.linkNum) {

                //     var linksOfNode = _.filter(links, function (link) {                          //filter all links for links of this node in new array
                //         return link.source == node.index || link.target == node.index;
                //     });

                //     console.log(linksOfNode)

                //     linksOfNode.forEach(function (link) {

                //         // var otherNode = link.source != node.index ? nodes[link.source] : nodes[link.target];        // for each link, get the other node
                //         var otherNode = link.source.index != node.index ? link.source : link.target;    
                //         if (otherNode.linkedNum > otherNode.linkNum && otherNode.power < node.power) {             // if the other node also has to delete links
                //             links.splice(link.index, 1);
                //             linksOfNode.splice(link.index, 1);
                //             node.linkedNum = node.linkedNum - 1;
                //             otherNode.linkedNum = otherNode.linkedNum - 1;
                //         }

                //     });

                // }
                else if (node.linkedNum < node.linkNum) {
                    // console.log('node', node)

                    var linksOfNode = _.filter(links, function (link) {                          //filter all links for links of this node in new array
                        return link.source.index == node.index || link.target.index == node.index;
                    });

                    // console.log('linksOfNode',linksOfNode)

                    var unavailableTargets = [];

                    unavailableTargets.push(node);

                    // console.log('unavailableTargets', unavailableTargets)     

                    linksOfNode.forEach(function (link) {                                        //List nodes with which links exist
                        if (link.source.index == node.index) { unavailableTargets.push(link.target) }
                        else if (link.target.index == node.index) { unavailableTargets.push(link.source) }
                    });

                    // const tempNodes = nodes.map(x => x);

                    // console.log('nodes', nodes)
                    // console.log('tempNodes', tempNodes)

                    // unavailableTargets.foreach(function (target) {
                    //     tempNodes.splice(target.index, 1);
                    // });

                    // var availableTargets = nodes.filter(function (node) {                                               //List Targets available for new links
                    //     return !unavailableTargets.includes(node);
                    // })

                    var availableTargets = _.differenceWith(nodes, unavailableTargets, _.isEqual);

                    // console.log('availableTargets', availableTargets)

                    availableTargets.forEach(function (target) {
                        var x = target.x - node.x
                        var y = target.y - node.y
                        var distanceToTarget = Math.sqrt(x * x + y * y)

                        while (node.linkedNum < node.linkNum
                            && target.linkedNum < target.linkNum
                            && (distanceToTarget < node.linkLength || distanceToTarget < target.linkLength)) {     // if the other node also wants links
                            newLink = { source: node, target: target }
                            links.push(newLink);
                            // linksOfNode.push(newLink);
                            node.linkedNum = node.linkedNum + 1;
                            target.linkedNum = target.linkedNum + 1;
                            // console.log('target', target)
                        }
                    })
                }
            }); 
            // console.log('links.length', links.length)
        }

        function visualise() {


            v = d3.select('svg')
                .selectAll('circle')
                .data(nodes, function (d) { return d })

            v.enter()
                .append('circle')
                .merge(v)
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr('r', function (d) { return d.r; })
                .style("fill", "#ff0000");

            v.exit().remove()

            var u = d3.select('svg')
                .selectAll('line')
                .data(links, function (d) { return d });

            u.enter()
                .append('line')
                .merge(u)
                // .transition()
                .attr("x1", function (d) {
                    return d.source.x;
                })
                .attr("y1", function (d) { return d.source.y; })
                .attr("x2", function (d) { return d.target.x; })
                .attr("y2", function (d) { return d.target.y; })
                .style("stroke", "#444444");

            u.exit().remove();
        }

        function initiate() {
            createNodes()
            updateLinks()
            simulation = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(10))
                .force('gravity', d3.forceCenter(w / 2, h / 2))
                .force('collision', d3.forceCollide(40).strength(.9))
                .force('link', d3.forceLink().links(links))
                .on("tick", visualise);
        }

        initiate()

        function centralise() {

            links.forEach(function (link) {

                var sourceNode = link.source;
                var targetNode = link.target;

                console.log('old sourceNode', sourceNode);
                console.log('old targetNode', targetNode);

                if (sourceNode.power >= targetNode.power && (targetNode.power - 10 % targetNode.power) > 15) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power;
                } else if (sourceNode.power <= targetNode.power && (sourceNode.power - 10 % sourceNode.power) > 15) {
                    sourceNode.power = sourceNode.power - 10 % sourceNode.power;
                    targetNode.power = targetNode.power + 10 % sourceNode.power
                }

                sourceNode.r = sourceNode.power / 10;
                sourceNode.linkLength = sourceNode.power * 4;
                sourceNode.linkNum = sourceNode.power / 10;

                targetNode.r = targetNode.power / 10;
                targetNode.linkLength = targetNode.power * 4;
                targetNode.linkNum = targetNode.power / 10;

                console.log('new sourceNode', sourceNode);
                console.log('new targetNode', targetNode);

                nodes[link.source.index] = sourceNode;
                nodes[link.target.index] = targetNode;

            });

            updateLinks()
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
            console.log("centralised")

        }

        function decentralise() {

            links.forEach(function (link) {

                var sourceNode = link.source;
                var targetNode = link.target;

                if (sourceNode.power >= targetNode.power && (sourceNode.power - 5 % sourceNode.power) > 15) {
                    sourceNode.power = sourceNode.power - 5 % sourceNode.power;
                    targetNode.power = targetNode.power + 5 % sourceNode.power;
                } else if (sourceNode.power <= targetNode.power && (targetNode.power - 5 % targetNode.power) > 15) {
                    sourceNode.power = sourceNode.power + 5 % targetNode.power;
                    targetNode.power = targetNode.power - 5 % targetNode.power
                }

                sourceNode.r = sourceNode.power / 10
                sourceNode.linkLength = sourceNode.power * 4;
                sourceNode.linkNum = sourceNode.power / 10;

                targetNode.r = targetNode.power / 10;
                targetNode.linkLength = targetNode.power * 4;
                targetNode.linkNum = targetNode.power / 10;

                nodes[link.source.index] = sourceNode;
                nodes[link.target.index] = targetNode;

            });

            updateLinks()
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
            console.log("centralised")
        }
    </script>
</body>

</html>