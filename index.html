<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>De/Centralise</title>
    <script type="text/javascript" src="d3/d3.js"></script>
  </head>

  <style>
    circle {
      fill: cadetblue;
    }
    line {
      stroke: #ccc;
    }
    /* text {
      text-anchor: middle;
      font-family: "Helvetica Neue", Helvetica, sans-serif;
      fill: #666;
      font-size: 16px;
    } */
    </style>

  <body>
    <div id="simulation"></div>
    <div>
        <button onClick="centralise();">Centralise</button>
    </div>
    <div>
        <button onClick="decentralise();">Decentralise</button>
    </div>
    
    <!-- JAVASCRIPT FILE -->
    <script type="text/javascript">

        var w = window.innerWidth - 20,
            h = window.innerHeight - 60;

        var svg = d3.select("#simulation").append("svg:svg")
            .attr("width", w)
            .attr("height", h);

        var link = d3.select("svg").append("line").selectAll("line")
        var node = d3.select("svg").append("circle").selectAll("circle");

        var numNodes = 100;
        var nodes = d3.range(numNodes).map(function(d, i) {
            return {
                radius: Math.random() * 5,
                category: i % 3,
                x: Math.random() * w,
                y: Math.random() * h,
                power: Math.random() * 200,
            }; 
        });

        var numLinks = 5;
        var links = [];

        while 

        function linkGenerator() {
            for (let i = 0; i < numNodes; ++i) {
                for (let j = i + 1; j < numNodes; ++j) {
                    const pi = nodes[i];
                    const pj = nodes[j];
                    const dx = pi.x - pj.x;
                    const dy = pi.y - pj.y;
                    const d2 = dx * dx + dy * dy;
                    if (d2 < 500) {
                        link = {source: pi, target: pj}
                        d3.merge(links, link);
                    }
                
                }
            }
            return links
        }

        linkGenerator();


        console.log(links);

        console.log(nodes);

        var simulate = d3.forceSimulation(nodes)
            .force('charge', d3.forceManyBody().strength(10))
            .force('gravity', d3.forceCenter(w / 2, h / 2))
            .force('collision', d3.forceCollide(20).strength(.3))
            .force('link', d3.forceLink().links(links))
            .on("tick", ticked);

            function updateLinks() {

                var u = d3.select('svg')
                        .selectAll('line')
                        .data(links)

                u.enter()
                    .append('line')
                    .merge(u)
                    .attr('x1', function(d) {
                    return d.source.x
                    })
                    .attr('y1', function(d) {
                    return d.source.y
                    })
                    .attr('x2', function(d) {
                    return d.target.x
                    })
                    .attr('y2', function(d) {
                    return d.target.y
                    })
                    

                u.exit().remove()
            }       

            function updateNodes() {
                var v = d3.select('svg')
                    .selectAll('circle')
                    .data(nodes)

                v.enter()
                .append('circle')
                .attr('r', 5)
                .merge(v)
                .attr('cx', function(d) {
                return d.x
                })
                .attr('cy', function(d) {
                return d.y
                })

                v.exit().remove()
            }

            d3.interval(function() {
                update(d3.shuffle(alphabet)
                    .slice(0, Math.floor(Math.random() * 26))
                    .sort());
            }, 1500);

            function ticked() {
                node.attr("cx", function(d) { return d.x; })
                    .attr("cy", function(d) { return d.y; })

                link.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });
            }

        
          
        function centralise() {
            //pick some nodes and provide more power
            //gather power from neighboring nodes
            //add links to these nodes from neightboring nodes
            //delete links to other neighboring nodes
            //run the simulation again.
        };

        function decentralise() {
            simulate
                .force('charge', d3.forceManyBody().strength(30))
                .on();
            //decrease power from nodes with power 
            //redistribute power to neighboring nodes
            //delete links from central nodes
            //add links among neighboring nodes
            //run the simulation again
        };
    </script>
  </body>
</html>