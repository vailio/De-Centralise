<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>De/Centralise</title>
    <script type="text/javascript" src="d3/d3.js"></script>
  </head>

  <style>
    circle {
      fill: cadetblue;
    }
    line {
      stroke: #ccc;
    }
    /* text {
      text-anchor: middle;
      font-family: "Helvetica Neue", Helvetica, sans-serif;
      fill: #666;
      font-size: 16px;
    } */
    </style>

  <body>
    <div id="simulation"></div>
    <div>
        <button onClick="centralise();">Centralise</button>
    </div>
    <div>
        <button onClick="decentralise();">Decentralise</button>
    </div>
    
    <!-- JAVASCRIPT FILE -->
    <script type="text/javascript">

        var w = window.innerWidth - 20,
            h = window.innerHeight - 60;

        var svg = d3.select("#simulation").append("svg:svg")
            .attr("width", w)
            .attr("height", h);

        // const minDistance = 40;
        // const maxDistance = 60;
        // const minDistance2 = minDistance * minDistance;
        // const maxDistance2 = maxDistance * maxDistance;


        //a node would need the following properties: 
        // x, y, vx, vy, index, power, 
        // nodes = simulate.nodes;
        
        var numNodes = 100;
        var nodes = d3.range(numNodes).map(function(d, i) {
            return {
                radius: Math.random() * 5,
                category: i % 3,
                x: Math.random() * w,
                y: Math.random() * h,
                power: Math.random() * 200,
            }; 
        });

        var links = [];

        function linkGenerator() {
            // links.splice(0, links.length)
            for (let i = 0; i < numNodes; ++i) {
                for (let j = i + 1; j < numNodes; ++j) {
                    const pi = nodes[i];
                    const pj = nodes[j];
                    const dx = pi.x - pj.x;
                    const dy = pi.y - pj.y;
                    const d2 = dx * dx + dy * dy;
                    if (d2 < 500) {
                        // context.globalAlpha = d2 > minDistance2 ? (maxDistance2 - d2) / (maxDistance2 - minDistance2) : 1;
                    //     context.beginPath();
                    //     context.moveTo(pi.x, pi.y);
                    //     context.lineTo(pj.x, pj.y);
                        link = {source: pi, target: pj}
                        d3.merge(links, link);
                    //     // exchange colors on contact
                    //     if(pi.color != pj.color){
                    //     pj.color = pi.color;
                    //     }
                    //     context.strokeStyle = pi.color;
                                            
                    //     context.stroke();
                                
                    }
                
                }
            }
            return links
        }

        linkGenerator();


        console.log(links);

        console.log(nodes);
        
        // Broadly speaking there are 4 steps to setting up a force 
        // simulation: 
        // 1. create an array of objects
        // 2. call forceSimulation, passing in the array of objects
        // 3. add one or more force functions (e.g. forceManyBody, 
        //    forceCenter, forceCollide) to the system
        // 4. set up a callback function to update the element positions 
        //    after each tick

        //Steps 3 & 4 of setting up force simulation: 
        var simulate = d3.forceSimulation(nodes)
                //forceManyBody gets all nodes to attract or repel each other
            .force('charge', d3.forceManyBody().strength(10))
                //forceCenter gets all nodes to be attracted to one point
            .force('gravity', d3.forceCenter(w / 2, h / 2))
            // .force('collision', d3.forceCollide().radius(function(d) {
            //     return d.radius * 1.5
            // }).iterations(10))
            .force('collision', d3.forceCollide(20).strength(.3))//.iterations(10))
                //forceX gets
            // .force('x', d3.forceX().x(function(d) {
            //     return xScale(d.value);
            // }))
                //forceLink gets to maintain a strength or a distance between 
                //the linked nodes.
            .force('link', d3.forceLink().links(links))
            .on("tick", ticked);

            function updateLinks() {

                // linkGenerator();

                var u = d3.select('svg')
                        .selectAll('line')
                        .data(links)

                u.enter()
                    .append('line')
                    .merge(u)
                    .attr('x1', function(d) {
                    return d.source.x
                    })
                    .attr('y1', function(d) {
                    return d.source.y
                    })
                    .attr('x2', function(d) {
                    return d.target.x
                    })
                    .attr('y2', function(d) {
                    return d.target.y
                    })
                    

                u.exit().remove()
            }       

            function updateNodes() {
                var v = d3.select('svg')
                    .selectAll('circle')
                    .data(nodes)

                v.enter()
                .append('circle')
                .attr('r', 5)//function(d) {return d.radius})//return Math.sqrt(d.power) / 3.14})
                .merge(v)
                .attr('cx', function(d) {
                return d.x
                })
                .attr('cy', function(d) {
                return d.y
                })

                v.exit().remove()
            }

            function ticked() {
                
                updateLinks()
                updateNodes()
                // console.log(links);
                
                linkGenerator()
            }


        // function ticked() {
        //     d3.select('svg')
        //         .selectAll('circle')
        //         .data(nodes)
        //         .enter()
        //         .append('circle')
        //         .attr('r', function(d) {return d.radius})//return Math.sqrt(d.power) / 3.14})
        //         .merge(u)
        //         .attr('cx', function(d) {
        //         return d.x
        //         })
        //         .attr('cy', function(d) {
        //         return d.y
        //         })

        //     d3.select('svg')
        //         .selectAll('circle')
        //         .data(nodes)
        //         .exit().remove()

        //     d3.select('svg')
        //         .selectAll('line')
        //         .enter()
        //         .append('line')
        //         .data([links])
        //         .attr("x1", function(d) { return d.source.x; })
        //         .attr("y1", function(d) { return d.source.y; })
        //         .attr("x2", function(d) { return d.target.x; })
        //         .attr("y2", function(d) { return d.target.y; })

        //     d3.select('svg')
        //         .selectAll('line')
        //         .data(links)
        //         .exit().remove()
        // }

        
        // var links = simulate.links;
            
        // add to the nodes and links arrays. 
        // links.push({});
        // nodes.push({});

        
        // Run this when Decentralise button is clicked    
        function centralise() {
            //pick some nodes and provide more power
            //gather power from neighboring nodes
            //add links to these nodes from neightboring nodes
            //delete links to other neighboring nodes
        };

        // Run this when Decentralise button is clicked
        function decentralise() {
            simulate
                .force('charge', d3.forceManyBody().strength(30))
                .on();
            //decrease power from nodes with power 
            //redistribute power to neighboring nodes
            //delete links from central nodes
            //add links among neighboring nodes
        };
        
        //step 2 of setting up a force simulation: call 
        //forceSimulation, passing in the array of objects  
        // simulate
            // simulation.nodes([nodes])
            // If nodes is specified, sets the simulationâ€™s nodes to the 
            // specified array of objects, initializing their positions 
            // and velocities if necessary, and then re-initializes any 
            // bound forces; returns the simulation.
            // .nodes(nodes)
            // .links(links)
            // simulation.on(typenames, [listener]) 
            // use simulation.on to listen for tick events as the simulation runs.
            // If listener is specified, sets the event listener 
            // for the specified typenames and returns this simulation.
            // typenames can be "tick" or "end"
            // .on("tick", ticked);

        // console.log(nodes);
    </script>
  </body>
</html>