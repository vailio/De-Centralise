<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />

    <title>De/Centralise</title>

</head>
<style>
    /* rect {
        fill: none;
        pointer-events: all;
    } */

    /* .circle {
        fill: #222;
    }

    .line {
        stroke: #333;
    } */
</style>

<body>
    <!-- <div id="simulation"></div> -->
    <div>
        <button onclick="centralise();">Centralise</button>
    </div>
    <div>
        <button onclick="decentralise();">Decentralise</button>
    </div>
    <script src="d3.js"></script>
    <script src="lodash.js"></script>
    <script type="text/javascript">

        var simulation = null;

        var w = window.innerWidth - 40,
            h = window.innerHeight - 40;

        var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h);

        d3.select('body').select('svg')
            .append("rect")
            .attr("width", w)
            .attr("height", h)
            .style('fill', "#000000")

        var nodes = d3.range(40).map(d => {
            var p = Math.floor((Math.random() * 100) + 1)
            return {
                power: p,
                x: (Math.random() * w) - p / 5,
                y: (Math.random() * h) - p / 5,
                linkedNum: 0,
                r: p / 5,
                linkLength: p * 4, //* (Math.sqrt(w * w + h * h )) / 100,
                linkNum: p / 10,
            }
        })

        function createNodes() {
            //CREATE NODES
            d3.select('svg')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .transition()
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr('r', function (d) { return d.r; })
                .style("fill", "#ff0000");
            // .attr('fill', 000000)
        }

        function createLinks() {
            d3.select('svg')
                .selectAll('line')
                .data(links, function (d) { return d })
                .enter()
                .append('line')
                // .merge(v)                                        
                .transition()
                .attr("x1", function (d) { return d.source.x; })
                .attr("y1", function (d) { return d.source.y; })
                .attr("x2", function (d) { return d.target.x; })
                .attr("y2", function (d) { return d.target.y; })
                .style("stroke", "#444444");
        }

        var links = []

        function updateLinks() {

            console.log('updateLinks start', nodes);

            nodes.forEach(function (node, index) {

                console.log('checking node #' + index, node);

                if (node.linkedNum > node.linkNum) {

                    var linksWhereNodeIsSourceOrTarget = _.filter(links, function (link) {                          //filter all links for links of this node in new array
                        return link.source == node.index || link.target == node.index;
                    });

                    console.log('node.linkedNum > node.linkNum linksWhereNodeIsSourceOrTarget', linksWhereNodeIsSourceOrTarget);

                    linksWhereNodeIsSourceOrTarget.forEach(function (link) {

                        var otherNode = link.source != node.index ? nodes[link.source] : nodes[link.target];        // for each link, get the other node

                        if (otherNode.linkedNum > otherNode.linkNum && otherNode.power <= node.power) {             // if the other node also has to delete links
                            links.splice(link.index, 1);
                            linksWhereNodeIsSourceOrTarget.splice(link.index, 1);
                            node.linkedNum = node.linkedNum - 1;
                            otherNode.linkedNum = otherNode.linkedNum - 1;
                        }

                    });

                } else if (node.linkedNum < node.linkNum) {

                    var linksWhereNodeIsSourceOrTarget = _.filter(links, function (link) {                          //filter all links for links of this node in new array
                        return link.source == node.index || link.target == node.index;
                    });

                    console.log('node.linkedNum < node.linkNum linksWhereNodeIsSourceOrTarget', linksWhereNodeIsSourceOrTarget);

                    var unavailableTargets = [];

                    unavailableTargets.push(node)

                    linksWhereNodeIsSourceOrTarget.forEach(function (link) {                                        //List nodes with which links exist
                        if (link.source == node.index) { unavailableTargets.push(link.target) }
                        else if (link.target == node.index) { unavailableTargets.push(link.source) }
                    });

                    console.log('unavailableTargets', unavailableTargets);

                    var availableTargets = nodes.filter(function (node) {                                               //List Targets available for new links
                        return !unavailableTargets.includes(node);
                    })

                    console.log('availableTargets', availableTargets);

                    availableTargets.forEach(function (target) {
                        var x = target.x - node.x
                        var y = target.y - node.y
                        var distanceToTarget = Math.sqrt(x * x + y * y)

                        if (node.linkedNum < node.linkNum
                            && target.linkedNum < target.linkNum
                            && distanceToTarget <= target.linkLength) {     // if the other node also wants links
                            newLink = { source: node, target: target }
                            links.push(newLink);
                            linksWhereNodeIsSourceOrTarget.push(newLink);
                            node.linkedNum = node.linkedNum + 1;
                            target.linkedNum = target.linkedNum + 1;
                        }
                    })

                    console.log('new links', links);

                }
            });
        }

        function visualise() {
            //REMOVE AND ADD LINKS

            var u = d3.select('svg')
                .selectAll('line')
                .data(links, function (d) { return d });

            u.enter()
                .append('line')
                // .merge(v)                                        
                // .transition()
                .attr("x1", function (d) {
                    return d.source.x;
                })
                .attr("y1", function (d) { return d.source.y; })
                .attr("x2", function (d) { return d.target.x; })
                .attr("y2", function (d) { return d.target.y; })
                .style("stroke", "#444444");

            u.exit().remove();

            // i don't know whow much will help

            // u = d3.select('svg')
            //                 .selectAll('line')                                      
            //                 .data(links, function(d) {return d})

            //             u.enter()                                       
            //                 .append('line')
            //                 .merge(u)                                     
            //                 .transition()
            //                     .attr("x1", function (d) {return d.source.x;})     
            //                     .attr("y1", function (d) {return d.source.y;})
            //                     .attr("x2", function (d) {return d.target.x;})
            //                     .attr("y2", function (d) {return d.target.y;})
            //                     .style("stroke",  "#444444");

            //             u.exit().remove()

            v = d3.select('svg')
                .selectAll('circle')
                .data(nodes, function (d) { return d })

            v.enter()
                .append('circle')
                .merge(v)
                // .transition()
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr('r', function (d) { return d.r; })
                .style("fill", "#ff0000");

            v.exit().remove()

            // d3.select('svg')
            //     .selectAll('line')
            //     .data(links, function (d) { return d })
            //     .exit().remove()

            // var v = d3.select('svg')
            //     .selectAll('link')                                      
            //     .data(links, function(d) {
            //         return d
            //     });

            // v.enter()                                       
            //     .append('line') 
            //     .merge(v)                                        
            //     .transition()
            //     .attr("x1", function (d) {
            //         console.log(d);
            //         return d.source.x;
            //     })     
            //     .attr("y1", function (d) {return d.source.y;})
            //     .attr("x2", function (d) {return d.target.x;})
            //     .attr("y2", function (d) {return d.target.y;})

            // var w = d3.select('svg')
            //     .selectAll('node')
            //     .data(nodes)             

            // w.enter()
            //     .append('circle')
            //     .transition()
            //     .attr('cx', function (d) { return d.x; })
            //     .attr('cy', function (d) { return d.y; })
            //     .attr('r', function (d) { return d.r; });

            // // //UPDATE NODES
            // d3.select('svg')
            //     .selectAll('circle')                                      
            //     .data(nodes, function (d) {return d;})
            //     .transition()
            //         .attr("cx", function (d) {return d.x;})
            //         .attr("cy", function (d) {return d.y;})
            //         .attr("r", function (d) {return d.r;})
        }

        function initiate() {
            createNodes()
            updateLinks()
            // createLinks()
            simulation = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(10))
                .force('gravity', d3.forceCenter(w / 2, h / 2))
                .force('collision', d3.forceCollide(20).strength(.3))
                .force('link', d3.forceLink().links(links))
                .on("tick", visualise);
        }

        initiate()

        function centralise() {

            console.log(nodes);

            links.forEach(function (link) {

                var sourceNode = link.source;
                var targetNode = link.target;

                if (sourceNode.power >= targetNode.power && targetNode.power > 10) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power;
                } else if (sourceNode.power < targetNode.power && sourceNode.power > 10) {
                    sourceNode.power = sourceNode.power - 10 % targetNode.power;
                    targetNode.power = targetNode.power + 10 % targetNode.power
                }

                sourceNode.r = sourceNode.power / 5;
                sourceNode.linkLength = sourceNode.power * 4; //* (Math.sqrt(w * w + h * h )) / 100,
                sourceNode.linkNum = sourceNode.power / 10;

                targetNode.r = targetNode.power / 5;
                targetNode.linkLength = targetNode.power * 4; //* (Math.sqrt(w * w + h * h )) / 100,
                targetNode.linkNum = targetNode.power / 10;

                nodes[link.source.index] = sourceNode;
                nodes[link.target.index] = targetNode;

            });

            // updateNodes()
            updateLinks()
            simulation.on("tick", visualise);
        }

        function decentralise() {

            links.forEach(function (link) {

                var sourceNode = nodes[link.source];
                var targetNode = nodes[link.target];

                if (sourceNode.power >= targetNode.power && targetNode.power > 10) {
                    sourceNode.power = sourceNode.power - 10 % targetNode.power;
                    targetNode.power = targetNode.power + 10 % targetNode.power;
                } else if (sourdeNode.power < targetNode.power && sourceNode.power > 10) {
                    sourceNode.power = sourceNode.power + 10 % targetNode.power;
                    targetNode.power = targetNode.power - 10 % targetNode.power
                }
            });

            updateNodes()
            updateLinks()
            simulate.on("tick", visualise);
        }
    </script>
</body>

</html>