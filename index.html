<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>De/Centralise</title>
</head>

<body>
    <div>
        <button onclick="centralise();">Centralise</button>
    </div>
    <div>
        <button onclick="decentralise();">Decentralise</button>
    </div>
    <script src="d3.js"></script>
    <script src="lodash.js"></script>
    <script type="text/javascript">

        var simulation = null;

        var w = window.innerWidth - 40,
            h = window.innerHeight - 40;

        var svg = d3.select("body").append("svg")
            .attr("width", w)
            .attr("height", h);

        d3.select('body').select('svg')
            .append("rect")
            .attr("width", w)
            .attr("height", h)
            .style('fill', "#FFFFFF")

        var nodes = d3.range(40).map(d => {
            var p = Math.floor((Math.random() * 100) + 10)
            return {
                power: p,
                x: (Math.random() * w) - p / 5,
                y: (Math.random() * h) - p / 5,
                linkedNum: 0,
                r: p / 10,
                linkLength: p * 4,
                linkNum: Math.floor(p / 10),
            }
        })

        function createNodes() {
            d3.select('svg')
                .selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .transition()
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr('r', function (d) { return d.r; })
                .style("fill", "#ff0000");
        }

        var links = []

        function updateLinks() {

            nodes.forEach(function (node) {

                var linksOfNode = _.filter(links, function (link) {
                    if (link.source == node || link.target == node) { return link };
                });

                if (node.linkedNum > node.linkNum) { // delete links from less powerful neighbors 

                    linksOfNode.forEach(function (link) {

                        var otherNode = link.source != node ? link.source : link.target;

                        if (node.linkedNum > node.linkNum
                            && otherNode.linkedNum > otherNode.linkNum) {
                            _.pull(links, link);
                            _.pull(linksOfNode, link);
                            node.linkedNum = node.linkedNum - 1;
                            otherNode.linkedNum = otherNode.linkedNum - 1;
                        }

                    });

                } else if (node.linkedNum < node.linkNum) { // add links to more powerful neighbors

                    var unavailableTargets = [node];

                    linksOfNode.forEach(function (link) {
                        if (link.source == node) { unavailableTargets.push(link.target) }
                        else if (link.target == node) { unavailableTargets.push(link.source) }
                    });

                    var availableTargets = _.differenceWith(nodes, unavailableTargets, _.isEqual); 

                    availableTargets.forEach(function (target) {
                        
                        var x = target.x - node.x
                        var y = target.y - node.y
                        var distanceToTarget = Math.sqrt(x * x + y * y)

                        if ((node.linkedNum < node.linkNum // add links to more powerful neighbors who can make more links
                            && target.linkedNum < target.linkNum)) {
                                newLink = { source: node, target: target }
                                links.push(newLink);
                                node.linkedNum = node.linkedNum + 1;
                                target.linkedNum = target.linkedNum + 1;
                        }
                    });
                }
            });
            var errorNodes = _.filter(nodes, function (node) {
                if (node.linkNum < node.linkedNum) { return node };
            });

        }

        function visualise() {


            v = d3.select('svg')
                .selectAll('circle')
                .data(nodes, function (d) { return d })

            v.enter()
                .append('circle')
                .merge(v)
                .attr('cx', function (d) { return d.x; })
                .attr('cy', function (d) { return d.y; })
                .attr('r', function (d) { return d.r; })
                .style("fill", "#ff0000");

            v.exit().remove()

            var u = d3.select('svg')
                .selectAll('line')
                .data(links, function (d) { return d });

            u.enter()
                .append('line')
                .merge(u)
                .attr("x1", function (d) {
                    return d.source.x;
                })
                .attr("y1", function (d) { return d.source.y; })
                .attr("x2", function (d) { return d.target.x; })
                .attr("y2", function (d) { return d.target.y; })
                .style("stroke", "#444444");

            u.exit().remove();

            w = d3.select('svg')
                .selectAll('text')
                .data(nodes, function (d) { return d })

            w.enter()
                .append('text')
                .merge(w)
                .text(function (d) { return d.index + "," + d.linkNum + ", ed" + d.linkedNum })
                .merge(u)
                .attr('x', function (d) { return d.x })
                .attr('y', function (d) { return d.y })
                // .attr('dy', function (d) {return 5})
                .style('fill', "#666666")

            w.exit().remove()
        }

        function initiate() {
            createNodes()
            updateLinks()
            simulation = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(80))
                .force('gravity', d3.forceCenter(w / 2, h / 2))
                .force('collision', d3.forceCollide(60).strength(.9))
                .force('link', d3.forceLink().links(links))
                .on("tick", visualise);
        }

        initiate()

        function centralise() {

            links.forEach(function (link) {

                var sourceNode = link.source;
                var targetNode = link.target;

                if (sourceNode.power >= targetNode.power && (targetNode.power - 10) > 10) {
                    sourceNode.power = sourceNode.power + 10; // % targetNode.power;
                    targetNode.power = targetNode.power - 10; // % targetNode.power;
                } else if (sourceNode.power <= targetNode.power && (sourceNode.power - 10) > 10) {
                    sourceNode.power = sourceNode.power - 10; // % sourceNode.power;
                    targetNode.power = targetNode.power + 10; // % sourceNode.power
                }

                sourceNode.r = sourceNode.power / 10;
                sourceNode.linkLength = sourceNode.power * 4;
                sourceNode.linkNum = Math.floor(sourceNode.power / 10);

                targetNode.r = targetNode.power / 10;
                targetNode.linkLength = targetNode.power * 4;
                targetNode.linkNum = Math.floor(targetNode.power / 10);

                nodes[link.source.index] = sourceNode;
                nodes[link.target.index] = targetNode;

            });

            updateLinks()
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();

        }

        function decentralise() {

            links.forEach(function (link) {

                var sourceNode = link.source;
                var targetNode = link.target;

                if (sourceNode.power >= targetNode.power && (sourceNode.power - 5) > 10) {
                    sourceNode.power = sourceNode.power - 5; //% sourceNode.power;
                    targetNode.power = targetNode.power + 5; // % sourceNode.power;
                } else if (sourceNode.power <= targetNode.power && (targetNode.power - 5) > 10) {
                    sourceNode.power = sourceNode.power + 5; // % targetNode.power;
                    targetNode.power = targetNode.power - 5; // % targetNode.power
                }

                sourceNode.r = sourceNode.power / 10
                sourceNode.linkLength = sourceNode.power * 4;
                sourceNode.linkNum = Math.floor(sourceNode.power / 10);

                targetNode.r = targetNode.power / 10;
                targetNode.linkLength = targetNode.power * 4;
                targetNode.linkNum = Math.floor(targetNode.power / 10);

                nodes[link.source.index] = sourceNode;
                nodes[link.target.index] = targetNode;

            });

            updateLinks()
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }
    </script>
</body>

</html>